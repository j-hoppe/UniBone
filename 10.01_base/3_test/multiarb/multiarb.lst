       1                                	.title Multi Arbitration DMA/INTR test
       2                                
       3                                	; *************************************************
       4                                	; Exercises several devices in parallel,
       5                                	; each with INTR and DMA
       6                                	; For a device XX we have
       7                                	; XXENAB - flag to enable device
       8                                	; XXBASE - base address of device
       9                                	; XXVEC - the INTR vector
      10                                	; XXISR - Interrupt Service
      11                                	; XXIFLG - flag which is incremented in ISR
      12                                	; XXBUF - data buffer for DMA transfer
      13                                	; XXINIT - Initialize device after RESET
      14                                	; XXGO - subroutine to initiate DMA and INTR
      15                                	; XXECNT - event counter, indicates activity
      16                                	; XXLABL - single char label to print activity
      17                                	;
      18                                	; Devices are
      19                                	; CO - serial console
      20                                	; RK - RK11/RK05 disk
      21                                	; RL - RL11/RL02 disk
      22                                	; RY - Serial RX211 Floppy,
      23                                	; DU - MSCP disk drive on UDA controller
      24                                
      25                                	; enable tests
      26 000001                         kwenab	=	1
      27 000000                         rkenab	=	0
      28 000000                         rlenab	=	0
      29 000000                         ryenab	=	0	; not yet tested
      30 000000                         duenab	=	0	; not yet implemeneted
      31                                
      32                                	.enable AMA
      33                                	.asect
      34                                
      35                                	; *************************************************
      36                                	; Vectors
      37                                
      38 000060                         	. = corvec
      39 000060 001170                  	.word	corisr		; RCV interrupt
      40 000062 000340                  	.word	340
      41 000064                         	. = coxvec
      42 000064 001204                  	.word	coxisr		; XMT interrupt
      43 000066 000340                  	.word	340
      44                                
      45 000001                         .if ne kwenab
      46 000100                         	. = kwvect
      47 000100 001430                  	.word	kwisr		; periodic interrupt
      48 000102 000340                  	.word	340
      49                                .endc
      50                                
      51 000000                         .if ne rlenab
      52                                	. = rlvect		; RL11
      53                                	.word	rlisr
      54                                	.word	340
      55                                .endc
      56                                
      57 000000                         .if ne rkenab
      58                                	. = rkvect		; RK11
      59                                	.word	rkisr
      60                                	.word	340
      61                                .endc
      62                                
      63 000000                         .if ne ryenab
      64                                	. = ryvect		; RX211
      65                                	.word	ryisr
      66                                	.word	340
      67                                .endc
      68                                
      69 000000                         .if ne duenab
      70                                	. = duvect		; UDA MSCP controller
      71                                	.word	duisr
      72                                	.word	340
      73                                .endc
      74                                
      75 177776                         psw	= 177776
      76 165020                         monitr	= 165020		; Monitor addr for back jump
      77                                
      78                                	; *************************************************
      79                                	; Main
      80 001000                         	. = 1000
      81 000776                         stack	= .-2
      82                                start:
      83 001000 012706  000776          	mov	#stack,sp
      84 001004 005037  177776          	clr	@#psw		; priorty level 0, allow INTR
      85                                	; Initialize devices
      86 001010 000005                  	reset
      87 001012 004737  001212          	call	corini
      88 001016 004737  001226          	call	coxini
      89 000001                         .if ne kwenab
      90 001022 004737  001442          	call	kwinit
      91                                .endc
      92 000000                         .if ne rkenab
      93                                	call	rkinit
      94                                .endc
      95 000000                         .if ne rlenab
      96                                	call	rlinit
      97                                .endc
      98 000000                         .if ne ryenab
      99                                	call	ryinit
     100                                .endc
     101 000000                         .if ne duenab
     102                                	call	duinit
     103                                .endc
     104                                
     105 001026 012701  001460          	mov	#shello,r1	; Print "Hello" message
     106 001032 004737  001242          	call	puts
     107                                
     108                                	; main loop: check interrupt flags, restart DMA
     109                                	; process serial input
     110                                loop:
     111 001036 004737  001050          	call	dokbd		; check keyboard input
     112 001042 004737  001110          	call	dodev		; check device activities
     113 001046 000773                  	br	loop
     114                                
     115                                
     116                                
     117                                	; --- check keyboard input
     118                                dokbd:
     119 001050 004737  001374          	call	getc
     120 001054 103014                  	bcc	9$		; nothing received
     121                                	; process char in r0
     122 001056 120027  000003          	cmpb	r0,#3
     123 001062 001007                  	bne	1$
     124 001064 012701  001551          	mov	#sbye,r1	; ^C: print "Bye", back to monitor
     125 001070 004737  001242          	call	puts
     126 001074 000005                  	reset			; stop devices
     127 001076 000137  165020          	jmp	monitr
     128                                1$:
     129                                	; echo chars without special meaning
     130 001102 004737  001354          	call	putc
     131                                9$:
     132 001106 000207                  	return
     133                                
     134                                	; -- check device activities
     135                                dodev:
     136                                	; For all devices: restart device DMA if Interrupt received
     137 000001                         .if ne kwenab
     138 001110 005737  001424          	tst	kwiflg
     139 001114 001412                  	beq	1$
     140 001116 005037  001424          	clr	kwiflg
     141 001122 004737  001456          	call	kwgo
     142 001126 012700  000127          	mov	#kwlabl,r0	; progress printout
     143 001132 012701  001426          	mov	#kwecnt,r1
     144 001136 004737  001144          	call	progrs
     145                                1$:
     146                                .endc
     147                                
     148 000000                         .if ne rkenab
     149                                	tst	rkiflg
     150                                	beq	2$
     151                                	clr	rkiflg
     152                                	call	rkgo
     153                                	mov	#rklabl,r0	; progress printout
     154                                	mov	#rkecnt,r1
     155                                	call	progrs
     156                                2$:
     157                                .endc
     158 000000                         .if ne rlenab
     159                                	tst	rliflg
     160                                	beq	3$
     161                                	clr	rliflg
     162                                	call	rlgo
     163                                	mov	#rllabl,r0	; progress printout
     164                                	mov	#rlecnt,r1
     165                                	call	progrs
     166                                3$:
     167                                .endc
     168 000000                         .if ne ryenab
     169                                	tst	ryiflg
     170                                	beq	4$
     171                                	clr	ryiflg
     172                                	call	rygo
     173                                	mov	#rylabl,r0	; progress printout
     174                                	mov	#ryecnt,r1
     175                                	call	progrs
     176                                4$:
     177                                .endc
     178 000000                         .if ne duenab
     179                                	tst	duiflg
     180                                	beq	5$
     181                                	clr	duiflg
     182                                	call	dugo
     183                                	mov	#dulabl,r0	; progress printout
     184                                	mov	#duecnt,r1
     185                                	call	progrs
     186                                5$:
     187                                .endc
     188                                
     189 001142 000207                  	return
     190                                
     191                                
     192                                	; progress
     193                                	; check if the counter with address in r1 is at
     194                                	; 1024. if yes, print the char in r0
     195                                progrs:
     196                                ;	 bic	 #777700,(r1)	 ; mask counter to 0..63
     197 001144 042711  177400          	bic	#777400,(r1)	; mask counter to 0..255
     198                                ;	 bic	 #776000,(r1)	 ; mask counter to 0..1023
     199 001150 001002                  	bne	9$
     200 001152 004737  001354          	call	putc		; is at 0: print label character
     201                                9$:
     202 001156 000207                  	return
     203                                
     204                                
     205                                
     206                                	.include ma_cons.mac
       1                                
       2                                	.title ma_cons - Serial Console I/O
       3 000060                         corvec= 060		; vector for Receiver
       4 000064                         coxvec= 064		; vector for Xmitter
       5                                
       6 177560                         corbas= 777560		; base addr of Receiver
       7 177564                         coxbas= 777564		; base addr of Xmitter
       8                                
       9                                
      10                                
      11                                	; -- ISRs, increment Interrupt FLags
      12                                
      13 001160 000001                  corifl:	.word	1	; Interrupt flags
      14 001162 000001                  coxifl:	.word	1
      15                                
      16 001164                         corbuf:	.blkw	1  	; data buffer
      17 001166                         coxbuf: .blkw 	1
      18                                
      19                                corisr:
      20 001170 013737  177562  001164  	mov	@#corbas+2,corbuf	; read char, clear INTR
      21 001176 005237  001160          	inc	corifl
      22 001202 000002                  	rti
      23                                
      24                                coxisr:
      25 001204 005237  001162          	inc	coxifl
      26 001210 000002                  	rti
      27                                
      28                                	; -- Initialize device after RESET
      29                                corini:
      30 001212 012737  000100  177560  	mov	#100,@#corbas	; Bit 6 = Receiver Interrupt Enable
      31 001220 005037  001160          	clr	corifl
      32 001224 000207                  	return
      33                                coxini:
      34 001226 012737  000100  177564  	mov	#100,@#coxbas	; Bit 6 = Transmitter Interrupt Enable
      35 001234 005037  001162          	clr	coxifl
      36 001240 000207                  	return
      37                                
      38                                
      39                                
      40                                	; -------- Console I/O --------
      41                                
      42                                	; puts - print a string
      43                                	; r1 = pointer, r0,r1 changed
      44                                puts:
      45 001242 112100                  	movb	(r1)+,r0	; load xmt char
      46 001244 001403                  	beq	1$		; string ends with 0
      47 001246 004737  001354          	call	@#putc
      48 001252 000773                  	br	puts		; transmit nxt char of string
      49 001254 000207                  1$:	return
      50                                
      51                                
      52                                	; putnum - print the octal number in r0
      53 001256                         numbf0:  .blkw	 10		 ; space to mount number string
      54 001276                         numbf1	=.
      55                                putnum:
      56 001276 010346                  	mov	r3,-(sp)
      57 001300 010002                  	mov	r0,r2		; r2 = shifter
      58 001302 012701  001276          	mov	#numbf1,r1	; r1 = buffer pointer, backwards
      59 001306 112741  000000          	movb	#0,-(r1)	; set terminating 0
      60                                	; repeat 6 times
      61 001312 012703  000006          	mov	#6,r3
      62                                1$:
      63 001316 010200                  	mov	r2,r0
      64                                	; extract lower 3 bits = octal digit
      65 001320 042700  177770          	bic	#177770,r0 ; r0 &= 0x07
      66 001324 062700  000060          	add	#60,r0	; r0 += '0'
      67 001330 110041                  	movb	r0,-(r1) ; write in buffer
      68 001332 000241                  	clc
      69 001334 006202                  	asr	r2	; shift to next digit
      70 001336 006202                  	asr	r2
      71 001340 006202                  	asr	r2
      72 001342 077313                  	sob	r3,1$	; loop for all 6 digits
      73                                
      74 001344 004737  001242          	call	@#puts
      75 001350 012603                  	mov	(sp)+,r3
      76 001352 000207                  	return
      77                                
      78                                
      79                                	; putc - output a single char
      80                                	; r0 = char
      81                                putc:
      82 001354 005037  001162          	clr	coxifl		; reset interrupt flag
      83 001360 010037  177566          	mov	r0,@#coxbas+2	; char into transmit buffer
      84 001364 005737  001162          1$:	tst	coxifl		; XMT RDY?
      85 001370 001775                  	beq	1$		; no, loop
      86                                	; UART is buffering: char only started to sent now
      87                                	; interrupt active until next putc
      88 001372 000207                  	return
      89                                
      90                                	; getc - poll and input a single char
      91                                	; result in r0
      92                                	; carry clear : nothing received
      93                                	; carry set: char received
      94                                getc:
      95 001374 005000                  	clr	r0
      96 001376 005737  001160          	tst	corifl
      97 001402 001002                  	bne	1$
      98 001404 000241                  	clc			; Carry clear, no Interrupt, nothing received
      99 001406 000207                  	return
     100                                1$:
     101 001410 013700  001164          	mov	corbuf,r0 	; Interrupt, return char
     102 001414 005037  001160          	clr	corifl		; reset interrupt flag
     103 001420 000261                  	sec			; Carry Set
     104 001422 000207                  	return
     104                                
     207 000001                         .if ne kwenab
     208                                	.include ma_kw.mac
       1                                	.title ma_kw - KW11 test driver
       2                                
       3                                	; KW11 raises INTR at 50 Hz
       4                                
       5 000100                         kwvect = 100		; vector of KW11 line clock
       6 177546                         kwbase = 777546		; base addr of KW11 register
       7 000127                         kwlabl = 'W		; label char
       8                                
       9                                
      10                                	; --- ISRs, increment Interrupt FLags
      11 001424 000001                  kwiflg:	.word	1	; Interrupt flags
      12                                
      13 001426 000001                  kwecnt:	.word	1	; event counter
      14                                
      15                                kwisr:
      16 001430 005237  001426          	inc	kwecnt			; register as event
      17 001434 005237  001424          	inc	kwiflg	; set ISR flag
      18 001440 000002                  	rti
      19                                
      20                                	; --- Initialize device after RESET
      21                                kwinit:
      22 001442 012737  000100  177546  	mov	#100,@#kwbase		; set  interrupt enable
      23 001450 005037  001426          	clr	kwecnt
      24 001454 000207                  	return
      25                                
      26                                	; --- Restart new INTR
      27                                kwgo:
      28                                	; nothing todo, INTR repeated automatically
      29                                	; bic	#200,@#kwbase		; clear INTERRUPT MONITOR bit
      30 001456 000207                  	return
      31                                
      31                                
     209                                .endc
     210 000000                         .if ne rkenab
     211                                	.include ma_rk.mac
     212                                .endc
     213 000000                         .if ne rlenab
     214                                	.include ma_rl.mac
     215                                .endc
     216 000000                         .if ne ryenab
     217                                	.include ma_ry.mac
     218                                .endc
     219 000000                         .if ne duenab
     220                                	.include ma_du.mac
     221                                .endc
     222                                	.include ma_strings.mac
       1                                
       2                                	.title ma_strings - String constants
       3                                shello:
       4 001460    015     012          	.byte	15,12		; space, CR, LF,
       5 001462    052     052     052  	.ascii	/*** Multi Device Interrupt&DMA test ***/
         001465    040     115     165  
         001470    154     164     151  
         001473    040     104     145  
         001476    166     151     143  
         001501    145     040     111  
         001504    156     164     145  
         001507    162     162     165  
         001512    160     164     046  
         001515    104     115     101  
         001520    040     164     145  
         001523    163     164     040  
         001526    052     052     052  
       6 001531    015     012          	.byte	15,12		; CR, LF
       7 001533    136     103     040  	.ascii	/^C to stop./
         001536    164     157     040  
         001541    163     164     157  
         001544    160     056          
       8 001546    015     012          	.byte	15,12		; CR, LF
       9 001550    000                  	.byte	0
      10                                
      11                                
      12                                sbye:
      13 001551    015     012          	.byte	15,12
      14 001553    107     157     157  	.ascii	/Good Bye!/
         001556    144     040     102  
         001561    171     145     041  
      15 001564    015     012          	.byte	15,12 	; CR, LF
      16 001566    000                  	.byte	0
      17                                
      17                                
     223                                
     224                                	.end
     225                                
     226                                
     227                                
     227                                
